{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "968b2745-bd15-4bdc-a6f2-23e7792cc220",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Matrix Addition (A + B):\n",
      " [[ 6  8]\n",
      " [10 12]]\n",
      "\n",
      "Matrix Subtraction (A - B):\n",
      " [[-4 -4]\n",
      " [-4 -4]]\n",
      "\n",
      "Matrix Multiplication (A * B):\n",
      " [[19 22]\n",
      " [43 50]]\n",
      "\n",
      "Element-wise Multiplication (A .* B):\n",
      " [[ 5 12]\n",
      " [21 32]]\n",
      "\n",
      "Determinant of A: -2.0\n",
      "\n",
      "Inverse of A:\n",
      " [[-2.   1. ]\n",
      " [ 1.5 -0.5]]\n"
     ]
    }
   ],
   "source": [
    "# Write Python code for addition, subtraction, multiplication, element-wise multiplication, determinant, the inverse of the matrix using NumPy and SciPy package.\n",
    "import numpy as np\n",
    "from scipy.linalg import inv, det\n",
    "\n",
    "# Define two 2x2 matrices for the demonstration\n",
    "A = np.array([[1, 2], [3, 4]])\n",
    "B = np.array([[5, 6], [7, 8]])\n",
    "\n",
    "# 1. Matrix Addition\n",
    "matrix_addition = A + B\n",
    "print(\"Matrix Addition (A + B):\\n\", matrix_addition)\n",
    "\n",
    "# 2. Matrix Subtraction\n",
    "matrix_subtraction = A - B\n",
    "print(\"\\nMatrix Subtraction (A - B):\\n\", matrix_subtraction)\n",
    "\n",
    "# 3. Matrix Multiplication (Dot Product)\n",
    "matrix_multiplication = np.dot(A, B)\n",
    "print(\"\\nMatrix Multiplication (A * B):\\n\", matrix_multiplication)\n",
    "\n",
    "# 4. Element-wise Multiplication (Hadamard Product)\n",
    "elementwise_multiplication = A * B\n",
    "print(\"\\nElement-wise Multiplication (A .* B):\\n\", elementwise_multiplication)\n",
    "\n",
    "# 5. Determinant of Matrix A\n",
    "determinant_A = det(A)\n",
    "print(\"\\nDeterminant of A:\", determinant_A)\n",
    "\n",
    "# 6. Inverse of Matrix A (if determinant is non-zero)\n",
    "if determinant_A != 0:\n",
    "    inverse_A = inv(A)\n",
    "    print(\"\\nInverse of A:\\n\", inverse_A)\n",
    "else:\n",
    "    print(\"\\nMatrix A is singular, cannot compute inverse.\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "5b6d7ab2-c28d-4e36-96b0-d8b56723a3b0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Eigenvalues of A: [6. 2.]\n",
      "\n",
      "Eigenvectors of A:\n",
      " [[ 0.70710678  0.70710678]\n",
      " [-0.70710678  0.70710678]]\n",
      "\n",
      "Dot product of eigenvectors 1 and 2: 0.0\n",
      "Eigenvectors are orthogonal.\n"
     ]
    }
   ],
   "source": [
    "#2. Write Python code to calculate eigenvalue and eigenvector of a matrix. Check the orthogonality of the eigenvector.\n",
    "import numpy as np\n",
    "\n",
    "# Define a square matrix\n",
    "A = np.array([[4, -2], [-2, 4]])\n",
    "\n",
    "# 1. Calculate eigenvalues and eigenvectors\n",
    "eigenvalues, eigenvectors = np.linalg.eig(A)\n",
    "\n",
    "print(\"Eigenvalues of A:\", eigenvalues)\n",
    "print(\"\\nEigenvectors of A:\\n\", eigenvectors)\n",
    "\n",
    "# 2. Check orthogonality of eigenvectors\n",
    "# The eigenvectors are orthogonal if the dot product of two eigenvectors is zero\n",
    "# Eigenvectors corresponding to different eigenvalues are orthogonal for symmetric matrices\n",
    "\n",
    "# Check dot product between each pair of eigenvectors\n",
    "dot_product_1_2 = np.dot(eigenvectors[:, 0], eigenvectors[:, 1])\n",
    "print(\"\\nDot product of eigenvectors 1 and 2:\", dot_product_1_2)\n",
    "\n",
    "# Orthogonality condition: Eigenvectors should be orthogonal if the dot product is 0\n",
    "if np.allclose(dot_product_1_2, 0):\n",
    "    print(\"Eigenvectors are orthogonal.\")\n",
    "else:\n",
    "    print(\"Eigenvectors are not orthogonal.\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3ee3d073-0ebd-4544-9698-20157b32fe15",
   "metadata": {},
   "outputs": [],
   "source": [
    "#3. Calculate span and basis of a vector space using Python.\n",
    "import numpy as np\n",
    "from sympy import Matrix\n",
    "\n",
    "# Define a set of vectors as rows or columns of a matrix\n",
    "# For example, let's take a 3x3 matrix of vectors\n",
    "vectors = np.array([[1, 2, 3],\n",
    "                    [4, 5, 6],\n",
    "                    [7, 8, 9]])\n",
    "\n",
    "# Step 1: Compute the rank of the matrix using NumPy (it gives the dimension of the column space)\n",
    "rank = np.linalg.matrix_rank(vectors)\n",
    "print(f\"Rank of the matrix (dimension of the span): {rank}\")\n",
    "\n",
    "# Step 2: Use SymPy to compute the reduced row echelon form (rref) of the matrix\n",
    "sympy_matrix = Matrix(vectors)\n",
    "\n",
    "# Reduced Row Echelon Form (RREF)\n",
    "rref_matrix, pivot_columns = sympy_matrix.rref()\n",
    "\n",
    "print(\"\\nReduced Row Echelon Form (RREF) of the matrix:\")\n",
    "print(rref_matrix)\n",
    "\n",
    "# Step 3: The pivot columns represent the linearly independent vectors (basis)\n",
    "basis_vectors = vectors[:, pivot_columns]\n",
    "print(\"\\nBasis vectors for the span:\")\n",
    "print(basis_vectors)\n",
    "\n",
    "# The span of the vectors is the set of all linear combinations of these basis vectors\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
